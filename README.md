# Description of Xeno's algorithms coding "something"

## Overview

The point of this is for my personal learning, then to show my abilities to
potential job prospect stewards, then to help others learn the same things.

My take on these matters is that I presume the world will help an old guy like
me surivive, somehow, anyway, so that I want to demonstrate to myself and
others the extent of my vital abilities so that optimal judgement may be made
by selecting players in projects of picking me for their activities, or not.
Ultimately, when I have made comfortable progress here, I hope to embed links
to it in my resume, as well as possibly other reference points.

I also hope to learn these things as an aid to both my general professional
abilities, which is to say beyond coding, and as a complement to my social
science interests, going back to my BA degree work at the University of
Washington, and things I've done around or related to those early interests.

## Coding Languages

My idealistic coding interests, at the time of this writing 2016/08/08, are
in C, Go, Julia, C++ and possibly Ruby.  My pragmatic professional interests
are in C, C++, Javascript, C#, Java, Python and Ruby.  I have hopes that Julia
and Go will eventually become popular enough for me to include on the second
list above.  I also have interests in odd languages like Eiffel, Haskell,
Elixir, Clojure, and Forth which at this point I don't expect to ever have time
to pursue.

It may also be a help to know I did much of this work in vim, using mostly
defaults, but a .exrc file with the following line:

set ts=4 sw=4

which indicates tab stop of 4 and shift width of 4.


## Patterns Priorities

At this time my pattern priorities are completely determined by an article
given me by a job search contact at Amazon, which is at this location:

	https://www.linkedin.com/pulse/20141120061048-6976444-ace-the-coding-interview-every-time?trk=mp-reader-card

This is not because I want to ace coding interviews.  Though I do like being
popular, and liked, I am not into sales on the other hand, so I just tend to
do the things that would make me like myself.  My permutation from reading
the above, at this time, is:

1.  Heap Sort (First instead of BSTs because it covers both Trees and Sorts)
2.  BSTs.
3.	Quick Sort
4.  Merge Sort with optional external storage mechanisms.
5.	Hashing.
6.  Graph Concepts generally.

Side note:  I like shells, but for now I am judging Bash and Powershell not
of personal interest in these exercises, except for administrative support.

## Coding Style

In case this matters, I try to make my coding style comply with some presently
popular ideas, some traditional ones, and focus on making the code easy to read
rather than easy to be right.  When there is a potential for miscoding because
there is a language specific subtlty, I may insert a comment explaining that,
and these I want to be open to enlightened criticism, as I expect the standard
infinity of potential improvement.  Still, the object is not perfection, but
learning.

Now all this being said, it is understood to begin with that those behaviors
work around the primary concept of programming a solution that is optimally
fast, good, and cheap.

## Cross Language Transitions

One of my goals is to maintain a file called Like at this top level directory
which helps me remember and others understand how to do like things across
programming languages.  We'll see how this works out.  It will probably be
more useful to me than others, if I make much progress at all.  I may also
divide it out into the subdirectories to simplify organization, but I'll see
when I get there.

## Miscellany

FYI:  Algo means "something" in Spanish.
